---
title: "Principios Solid en React Parte 2 - DIP"
pubDate: "2020-08-18"
slug: "solid principles-react-2"
description: "Principios Solid en React Parte 2 - Principio de Inversion de deprendencia."
hero: "/images/solid2.webp"
tags: ["javascript"]
layout: "../../layouts/BlogPostLayout.astro"
draft: false
---

## Motivaci√≥n

Este art√≠culos es la segunda parte de la saga de principios solid en React. En esta oportunidad hablaremos del principio de inversion de dependencia o DIP.
<a href="https://konstantinlebedev.com/solid-in-react/" target="_blank">Traducci√≥n</a>

## Principio de responsabilidad √∫nica (SRP)

El principio de inversi√≥n de dependencia establece que ‚Äúuno debe depender de abstracciones, no de concreciones‚Äù. Pero qupe significa √©sto? Dicho de otra manera, un componente no deber√≠a depender directamente de otro componente, sino que ambos deber√≠an depender de alguna abstracci√≥n com√∫n. Aqu√≠, componente se refiere a cualquier parte de nuestra aplicaci√≥n, ya sea un componente de React, una funci√≥n, un m√≥dulo o una biblioteca de terceros. Este principio puede ser dif√≠cil de comprender en abstracto, as√≠ que pasemos directamente a un ejemplo.

A continuaci√≥n, tenemos el componente `LoginForm` que env√≠a las credenciales de usuario a alguna API cuando se env√≠a el formulario:

```js
import api from "~/common/api";
const LoginForm = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const handleSubmit = async (evt) => {
    evt.preventDefault();
    await api.login(email, password);
  };
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button type="submit">Log in</button>
    </form>
  );
};
```

En este fragmento de c√≥digo, nuestro `LoginForm` hace referencia directamente al modulo importado `api`, por lo que existe un estrecho acoplamiento entre ellos (nuestro componente depende directamente de √©l). Esto no es aconsejable debido a que dicha dependencia hace que sea m√°s dif√≠cil realizar cambios en nuestro c√≥digo, ya que un cambio en un componente afectar√° a otros componentes. El principio de inversi√≥n de dependencia aboga por romper dicho acoplamiento (dependencia), as√≠ que veamos c√≥mo podemos lograrlo.

Primero, vamos a eliminar la referencia directa al m√≥dulo `api` desde el interior del `LoginForm`, y en su lugar, permitiremos que la funcionalidad requerida se inyecte a trav√©s de propiedades:

```js
type Props = {
  onSubmit: (email: string, password: string) => Promise<void>,
};
const LoginForm = ({ onSubmit }: Props) => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const handleSubmit = async (evt) => {
    evt.preventDefault();
    await onSubmit(email, password);
  };
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button type="submit">Log in</button>
    </form>
  );
};
```

Con este cambio, nuestro `LoginForm` ya no depende del m√≥dulo `api`. La l√≥gica para enviar credenciales a la API se abstrae a trav√©s de del callback `onSubmit` y ahora es responsabilidad del componente principal proporcionar la implementaci√≥n concreta de esta l√≥gica.

Para hacer eso, crearemos una versi√≥n conectada de `LoginForm` que delegar√° la l√≥gica de env√≠o de formularios al m√≥dulo `api`:

```js
import api from "~/common/api";
const ConnectedLoginForm = () => {
  const handleSubmit = async (email, password) => {
    await api.login(email, password);
  };
  return <LoginForm onSubmit={handleSubmit} />;
};
```

`ConnectedLoginForm` sirve como un intermediario entre `api` y `LoginForm`, mientras que ellos mismos permanecen totalmente independientes entre s√≠. Podemos iterarlos y probarlos de forma aislada sin preocuparnos por romper las piezas m√≥viles dependientes, ya que no hay ninguna. Y mientras ambos `LoginForm` y `api` sigan la abstracci√≥n com√∫n acordada, la aplicaci√≥n en su conjunto seguir√° funcionando como se esperaba.

> Para concluir, el principio de inversi√≥n de dependencia tiene como objetivo minimizar el acoplamiento entre diferentes componentes de la aplicaci√≥n. Como probablemente haya notado, la minimizaci√≥n es un tema recurrente en todos los principios de SOLID, desde minimizar el alcance de las responsabilidades de los componentes individuales hasta minimizar las dependencias entre ellos.

Nos vemos en el siguiente cap√≠tulo donde hablaremos del `Principio de Sustituci√≥n de Liskov`. üëã
